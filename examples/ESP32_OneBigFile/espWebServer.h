#include <FS.h>
#include <WiFiClient.h>

/* Notes on filesystem used:
On ESP8266 platform the best choice is LittleFS (SPIFFS is now deprecated);

On ESP32 platform FFat will be used:
SPIFFS don't support folders and is slower respect to others filesystems.

Unfortunately, there is still no valid file system upload tool (like SPIFFS).
To overcome this problem, define the INCLUDE_FALLBACK_INDEX_HTM option: 
with  http://yorhostname.local/edit page, you can easily upload all the files necessary 
for the webserver directly from the browser
*/

// Uncomment the following line to embed a version of the web page in the code
// (program code will be larger, but no file will have to be written to the filesystem).
// Note: the source file "extras/index_htm.h" must have been generated by "extras/reduce_index.sh"

#define INCLUDE_FALLBACK_INDEX_HTM

#ifdef INCLUDE_FALLBACK_INDEX_HTM
#include "extras/index_htm.h"
#endif

String unsupportedFiles = String();
File uploadFile;


// With ESP8266 is better to use LittleFS
#ifdef ESP8266
  #include <ESP8266WiFi.h>
  #include <ESP8266WebServer.h>
  #include <ESP8266mDNS.h>  
  ESP8266WebServer server(80);

// LittleFS is not supported on ESP32 platform
#elif defined(ESP32) 
  #include <WiFi.h>
  #include <WebServer.h>
  #include <ESPmDNS.h>
  WebServer server(80);
  struct FSInfo {
      size_t totalBytes;
      size_t usedBytes;
  };
#endif

static const char TEXT_PLAIN[] PROGMEM = "text/plain";
static const char FS_INIT_ERROR[] PROGMEM = "FS INIT ERROR";
static const char FILE_NOT_FOUND[] PROGMEM = "FileNotFound";

#define DBG_OUTPUT_PORT Serial

////////////////////////////////
// Utils to return HTTP codes, and determine content-type

void replyOK() {
    server.send(200, FPSTR(TEXT_PLAIN), "");
}

void replyOKWithMsg(String msg) {
    server.send(200, FPSTR(TEXT_PLAIN), msg);
}

void replyNotFound(String msg) {
    server.send(404, FPSTR(TEXT_PLAIN), msg);
}

void replyBadRequest(String msg) {
    DBG_OUTPUT_PORT.println(msg);
    server.send(400, FPSTR(TEXT_PLAIN), msg + "\r\n");
}

void replyServerError(String msg) {
    DBG_OUTPUT_PORT.println(msg);
    server.send(500, FPSTR(TEXT_PLAIN), msg + "\r\n");
}


#ifdef ESP32
void updateFsInfo(FSInfo* fsInfo) {
    fsInfo->totalBytes = fileSystem.totalBytes();
    #ifdef _SPIFFS_H_
        fsInfo->usedBytes = fileSystem.usedBytes();
    #else
        fsInfo->usedBytes = fileSystem.totalBytes() - fileSystem.freeBytes();
    #endif
}
#endif


////////////////////////////////
// Request handlers

/*
    Return the FS type, status and size info
*/
void handleStatus() {
    DBG_OUTPUT_PORT.println(PSTR("handleStatus"));
    FSInfo fs_info;
    String json;
    json.reserve(128);

    json = "{\"type\":\"";
    json += fsName;
    json += "\", \"isOk\":";
    if (fsOK) {
#ifdef ESP8266
        fileSystem.info(fs_info);
#else
        updateFsInfo(&fs_info);
#endif
        json += PSTR("\"true\", \"totalBytes\":\"");
        json += fs_info.totalBytes;
        json += PSTR("\", \"usedBytes\":\"");
        json += fs_info.usedBytes;
        json += "\"";
    }
    else {
        json += "\"false\"";
    }
    json += PSTR(",\"unsupportedFiles\":\"");
    json += unsupportedFiles;
    json += "\"}";

    server.send(200, "application/json", json);
}


/*
    Return the list of files in the directory specified by the "dir" query string parameter.
    Also demonstrates the use of chuncked responses.
*/
#ifdef ESP32
void handleFileList() {
    if (!fsOK) {
        return replyServerError(FPSTR(FS_INIT_ERROR));
    }

    if (!server.hasArg("dir")) {
        return replyBadRequest(PSTR("DIR ARG MISSING"));
    }

    String path = server.arg("dir");
    DBG_OUTPUT_PORT.printf_P(PSTR("handleFileList: %s\n"), path.c_str());

    File dir = fileSystem.open(path);
    if (!dir.isDirectory()) {
        return replyBadRequest("BAD PATH");
    }
    path.clear();

    String output = "[";
    File file = dir.openNextFile();
    while (file) {
        output += PSTR("{\"type\":\"");
        if (file.isDirectory()) {
            output += PSTR("dir");
        }
        else {
            output += PSTR("file\",\"size\":\"");
            output += file.size();
        }
        // remove absolute path from file name
        String filename = file.name();
        if (filename.lastIndexOf('/') > 0) {
            filename = filename.substring(filename.lastIndexOf('/'));
        }
        // Always return names without leading "/"
        if (filename[0] == '/') {
            filename = filename.substring(1);
        }

        output += PSTR("\",\"name\":\"");
        output += filename;
        file = dir.openNextFile();
        if (file)
            output += PSTR("\"},");
        else
            output += PSTR("\"}");  // last file
    }
    output += PSTR("]");
    DBG_OUTPUT_PORT.println(output);
    server.send(200, "application/json; charset=utf-8", output);
}
#elif defined (ESP8266)

void handleFileList() {
  if (!fsOK) {
    return replyServerError(FPSTR(FS_INIT_ERROR));
  }

  if (!server.hasArg("dir")) {
    return replyBadRequest(PSTR("DIR ARG MISSING"));
  }

  String path = server.arg("dir");
  if (path != "/" && !fileSystem.exists(path)) {
    return replyBadRequest(PSTR("BAD PATH"));
  }

  
  DBG_OUTPUT_PORT.printf_P(PSTR("handleFileList: %s\n"), path.c_str());
  Dir dir = fileSystem.openDir(path);
  path.clear();

  // use the same string for every line
  String output = "[";
  output.reserve(64);
  while (dir.next()) {
    if (output.length() > 1) {
      output += ',';
    }

    output += "{\"type\":\"";
    if (dir.isDirectory()) {
      output += "dir";
    } else {
      output += PSTR("file\",\"size\":\"");
      output += dir.fileSize();
    }

    output += PSTR("\",\"name\":\"");
    // Always return names without leading "/"
    if (dir.fileName()[0] == '/') {
      output += &(dir.fileName()[1]);
    } else {
      output += dir.fileName();
    }
    output += "\"}";
  }

  // send last string
  output += "]";
  server.send(200, "application/json; charset=utf-8", output);
}
#endif


const char* getContentType(const char* filename) {
    if (server.hasArg("download")) {
        return "application/octet-stream";
    }
    else if (strstr(filename, ".htm")) {
        return "text/html";
    }
    else if (strstr(filename, ".html")) {
        return "text/html";
    }
    else if (strstr(filename, ".css")) {
        return "text/css";
    }
    else if (strstr(filename, ".js")) {
        return "application/javascript";
    }
    else if (strstr(filename, ".png")) {
        return "image/png";
    }
    else if (strstr(filename, ".gif")) {
        return "image/gif";
    }
    else if (strstr(filename, ".jpg")) {
        return "image/jpeg";
    }
    else if (strstr(filename, ".ico")) {
        return "image/x-icon";
    }
    else if (strstr(filename, ".xml")) {
        return "text/xml";
    }
    else if (strstr(filename, ".pdf")) {
        return "application/x-pdf";
    }
    else if (strstr(filename, ".zip")) {
        return "application/x-zip";
    }
    else if (strstr(filename, ".gz")) {
        return "application/x-gzip";
    }
    return "text/plain";
}


/*
    Checks filename for character combinations that are not supported by FSBrowser (alhtough valid on SPIFFS).
    Returns an empty String if supported, or detail of error(s) if unsupported
*/
String checkForUnsupportedPath(String filename) {
    
    String error = String();
    if (!filename.startsWith("/")) {
        error += PSTR(" !! NO_LEADING_SLASH !! ");
    }
    if (filename.indexOf("//") != -1) {
        error += PSTR(" !! DOUBLE_SLASH !! ");
    }
    if (filename.endsWith("/")) {
        error += PSTR(" ! TRAILING_SLASH ! ");
    }
    Serial.println(filename);
    Serial.println(error);
    return error;
}


/*
    Read the given file from the filesystem and stream it back to the client
*/
bool handleFileRead( String path) {
    DBG_OUTPUT_PORT.printf_P(PSTR("handleFileRead: %s\n"), path.c_str());
  
    if (!fsOK) {
        replyServerError(FPSTR(FS_INIT_ERROR));
        return true;
    }

    if (path.endsWith("/")) {
        path += "index.htm";
    }

    String contentType;
    if (server.hasArg("download")) {
        contentType = PSTR("application/octet-stream");
    }
    else {
        contentType = getContentType(path.c_str());
    }

    if (!fileSystem.exists(path)) {
        // File not found, try gzip version
        path = path + ".gz";
    }
    if (fileSystem.exists(path)) {
        File file = fileSystem.open(path, "r");
        if (server.streamFile(file, contentType) != file.size()) {
            DBG_OUTPUT_PORT.println(PSTR("Sent less data than expected!"));
        }
        file.close();
        return true;
    }

    return false;
}


/*
    As some FS (e.g. LittleFS) delete the parent folder when the last child has been removed,
    return the path of the closest parent still existing
*/
String lastExistingParent(String path) {
    while (!path.isEmpty() && !fileSystem.exists(path)) {
        if (path.lastIndexOf('/') > 0) {
            path = path.substring(0, path.lastIndexOf('/'));
        }
        else {
            path = String();  // No slash => the top folder does not exist
        }
    }
    DBG_OUTPUT_PORT.printf_P(PSTR("Last existing parent: %s\n"), path.c_str());
    return path;
}

/*
    Handle the creation/rename of a new file
    Operation      | req.responseText
    ---------------+--------------------------------------------------------------
    Create file    | parent of created file
    Create folder  | parent of created folder
    Rename file    | parent of source file
    Move file      | parent of source file, or remaining ancestor
    Rename folder  | parent of source folder
    Move folder    | parent of source folder, or remaining ancestor
*/
void handleFileCreate() {
    if (!fsOK) {
        return replyServerError(FPSTR(FS_INIT_ERROR));
    }

    String path = server.arg("path");
    if (path.isEmpty()) {
        return replyBadRequest(PSTR("PATH ARG MISSING"));
    }

    if (path == "/") {
        return replyBadRequest("BAD PATH");
    }
    if (fileSystem.exists(path)) {
        return replyBadRequest(PSTR("PATH FILE EXISTS"));
    }

    String src = server.arg("src");
    if (src.isEmpty()) {
        // No source specified: creation        
        DBG_OUTPUT_PORT.printf_P(PSTR("handleFileCreate: %s\n"), path.c_str());
        if (path.endsWith("/")) {
            // Create a folder
            path.remove(path.length() - 1);
            if (!fileSystem.mkdir(path)) {
                return replyServerError(PSTR("MKDIR FAILED"));
            }
        }
        else {
            // Create a file
            File file = fileSystem.open(path, "w");
            if (file) {
                file.write(0);
                file.close();
            }
            else {
                return replyServerError(PSTR("CREATE FAILED"));
            }
        }
        if (path.lastIndexOf('/') > -1) {
            path = path.substring(0, path.lastIndexOf('/'));
        }
        replyOKWithMsg(path);
    }
    else {
        // Source specified: rename
        if (src == "/") {
            return replyBadRequest("BAD SRC");
        }
        if (!fileSystem.exists(src)) {
            return replyBadRequest(PSTR("SRC FILE NOT FOUND"));
        }
 
        DBG_OUTPUT_PORT.printf_P(PSTR("handleFileCreate: %s from %s\n"), path.c_str(), src.c_str());

        if (path.endsWith("/")) {
            path.remove(path.length() - 1);
        }
        if (src.endsWith("/")) {
            src.remove(src.length() - 1);
        }
        if (!fileSystem.rename(src, path)) {
            return replyServerError(PSTR("RENAME FAILED"));
        }
        replyOKWithMsg(lastExistingParent(src));
    }
}


/*
    Delete the file or folder designed by the given path.
    If it's a file, delete it.
    If it's a folder, delete all nested contents first then the folder itself

    IMPORTANT NOTE: using recursion is generally not recommended on embedded devices and can lead to crashes (stack overflow errors).
    This use is just for demonstration purpose, and FSBrowser might crash in case of deeply nested filesystems.
    Please don't do this on a production system.
*/
void deleteRecursive(String path) {
    File root = fileSystem.open(path, "r");
    bool isDir = root.isDirectory();
    root.close();

    // If it's a plain file, delete it
    if (!isDir) {
        fileSystem.remove(path);
        return;
    }

    // Otherwise delete its contents first
    File file = root.openNextFile();
    while (file) {
        String pFile = path + file.name();
        fileSystem.remove(pFile);
        file = root.openNextFile();
    }

    // Then delete the folder itself
    fileSystem.rmdir(path);
}


/*
    Handle a file deletion request
    Operation      | req.responseText
    ---------------+--------------------------------------------------------------
    Delete file    | parent of deleted file, or remaining ancestor
    Delete folder  | parent of deleted folder, or remaining ancestor
*/
void handleFileDelete() {
    if (!fsOK) {
        return replyServerError(FPSTR(FS_INIT_ERROR));
    }

    String path = server.arg(0);
    if (path.isEmpty() || path == "/") {
        return replyBadRequest("BAD PATH");
    }

    DBG_OUTPUT_PORT.printf_P(PSTR("handleFileDelete: %s\n"), path.c_str());
    if (!fileSystem.exists(path)) {
        return replyNotFound(FPSTR(FILE_NOT_FOUND));
    }
    deleteRecursive(path);

    replyOKWithMsg(lastExistingParent(path));
}

/*
    Handle a file upload request
*/
void handleFileUpload() {
    if (!fsOK) {
        return replyServerError(FPSTR(FS_INIT_ERROR));
    }
    if (server.uri() != "/edit") {
        return;
    }
    HTTPUpload& upload = server.upload();
    if (upload.status == UPLOAD_FILE_START) {
        String filename = upload.filename;
        // Make sure paths always start with "/"
        if (!filename.startsWith("/")) {
            filename = "/" + filename;
        }

        Serial.println("check name");
        if (checkForUnsupportedPath(filename).length() > 0) {
            return replyServerError(PSTR("INVALID FILENAME"));
        }

        DBG_OUTPUT_PORT.printf_P(PSTR("handleFileUpload Name: %s\n"), filename.c_str());
        uploadFile = fileSystem.open(filename, "w");
        if (!uploadFile) {
            return replyServerError(PSTR("CREATE FAILED"));
        }
        DBG_OUTPUT_PORT.printf_P(PSTR("Upload: START, filename: %s\n"), filename.c_str());
    }
    else if (upload.status == UPLOAD_FILE_WRITE) {
        if (uploadFile) {
            size_t bytesWritten = uploadFile.write(upload.buf, upload.currentSize);
            if (bytesWritten != upload.currentSize) {
                return replyServerError(PSTR("WRITE FAILED"));
            }
        }
        DBG_OUTPUT_PORT.printf_P(PSTR("Upload: WRITE, Bytes: %d\n"), upload.currentSize);
    }
    else if (upload.status == UPLOAD_FILE_END) {
        if (uploadFile) {
            uploadFile.close();
        }
        DBG_OUTPUT_PORT.printf_P(PSTR("Upload: END, Size: %d\n"), upload.totalSize);
    }
}


/*
    The "Not Found" handler catches all URI not explicitely declared in code
    First try to find and return the requested file from the filesystem,
    and if it fails, return a 404 page with debug information
*/
void handleNotFound() {
    if (!fsOK) {
        return replyServerError(FPSTR(FS_INIT_ERROR));
    }

#ifdef ESP32
    String uri = WebServer::urlDecode(server.uri()); // required to read paths with blanks
#elif defined(ESP8266)
    String uri = ESP8266WebServer::urlDecode(server.uri()); // required to read paths with blanks
#endif

    if (handleFileRead(uri)) {
        return;
    }
    // Dump debug data
    String message;
    message.reserve(100);
    message = PSTR("Error: File not found\n\nURI: ");
    message += uri;
    message += PSTR("\nMethod: ");
    message += (server.method() == HTTP_GET) ? "GET" : "POST";
    message += PSTR("\nArguments: ");
    message += server.args();
    message += '\n';
    for (uint8_t i = 0; i < server.args(); i++) {
        message += PSTR(" NAME:");
        message += server.argName(i);
        message += PSTR("\n VALUE:");
        message += server.arg(i);
        message += '\n';
    }
    message += "path=";
    message += server.arg("path");
    message += '\n';
    DBG_OUTPUT_PORT.print(message);

    return replyNotFound(message);
}

/*
    This specific handler returns the index.htm (or a gzipped version) from the /edit folder.
    If the file is not present but the flag INCLUDE_FALLBACK_INDEX_HTM has been set, falls back to the version
    embedded in the program code.
    Otherwise, fails with a 404 page with debug information
*/
void handleGetEdit() {

    if (handleFileRead(PSTR("/edit/index.htm"))) {
        return;
    }

#ifdef INCLUDE_FALLBACK_INDEX_HTM
    server.sendHeader(PSTR("Content-Encoding"), "gzip");
    server.send_P(200, "text/html", index_htm_gz, index_htm_gz_len);
#else
    replyNotFound(FPSTR(FILE_NOT_FOUND));
#endif

}


////////////////////////////////
// WEB SERVER INIT
void startWebServer(){

// Filesystem status
server.on("/status", HTTP_GET, handleStatus);

// List directory
server.on("/list", HTTP_GET, handleFileList);

// Load editor
server.on("/edit", HTTP_GET, handleGetEdit);

// Create file
server.on("/edit",  HTTP_PUT, handleFileCreate);

// Delete file
server.on("/edit",  HTTP_DELETE, handleFileDelete);

// Upload file
// - first callback is called after the request has ended with all parsed arguments
// - second callback handles file upload at that location
server.on("/edit",  HTTP_POST, replyOK, handleFileUpload);

// Default handler for all URIs not defined above, use it to read files from filesystem
server.onNotFound(handleNotFound);

// Start server
server.begin();
DBG_OUTPUT_PORT.println(PSTR("HTTP server started"));
}
